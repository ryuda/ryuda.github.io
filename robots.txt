// tools/scan-apis.mjs
// 목적: 엔드포인트 스캔 + Swagger 설명 + v1/v2 버전 + RequestBody는 오직 @RequestBody 타입의 클래스(파일)에서만 생성
// 환경: Node (ESM), 외부 라이브러리 없음

import fs from 'fs';
import path from 'path';

const root = process.cwd();
const SRC_DIRS = ['src', 'src/main/java', 'src/main/kotlin'];
const TARGET_EXTS = new Set(['.java', '.kt', '.js', '.ts', '.jsx', '.tsx']); // js/ts는 엔드포인트 탐지/Swagger 설명에만 사용

// -------- 샘플 값 매핑 --------
const typeSample = (t) => {
  const s = (t || '').toLowerCase();
  if (/(^|[\W_])(int|long|double|float|number)([\W_]|$)/.test(s)) return 0;
  if (/bool|boolean/.test(s)) return true;
  if (/date|localdate|localdatetime|instant|zoneddatetime/.test(s)) return '2025-01-01T00:00:00Z';
  if (/uuid/.test(s)) return '00000000-0000-0000-0000-000000000000';
  if (/byte\[\]|bytes/.test(s)) return '';
  if (/^string$|char|text/.test(s)) return 'string';
  if (/list|array|\[\]$/.test(s)) return [];
  if (/map/.test(s)) return {};
  return 'string';
};

const normPath = (p) => (p || '').replace(/\/+/g, '/').replace(/\/$/, '') || '/';
const extractVersion = (p) => {
  const m = /^\/?(v\d+)\b/i.exec(p || '');
  return m ? m[1].toLowerCase() : null;
};
const readText = (f) => { try { return fs.readFileSync(f, 'utf8'); } catch { return ''; } };
const indexToLine = (text, idx) => text.slice(0, idx).split('\n').length;

// -------- 파일 수집 --------
const walk = (dir, out = []) => {
  if (!fs.existsSync(dir)) return out;
  for (const ent of fs.readdirSync(dir, { withFileTypes: true })) {
    if (ent.name.startsWith('.')) continue;
    const p = path.join(dir, ent.name);
    if (ent.isDirectory()) walk(p, out);
    else {
      const ext = path.extname(ent.name);
      if (TARGET_EXTS.has(ext)) out.push(p);
    }
  }
  return out;
};
const allFiles = SRC_DIRS.flatMap((d) => walk(path.join(root, d)));

// -------- 클래스 인덱스 (Spring DTO/POJO/Kotlin data class) --------
/**
 * classIndex: Map<className, {fields:[{name,type}], file}>
 * - Java: "class Xxx { private Type name; }"
 * - Kotlin: "data class Xxx(val name: Type, ...)" 또는 일반 class 필드
 */
const classIndex = new Map();

const parseJavaClasses = (text, file) => {
  // public class Foo { ... }
  const classRe = /\bclass\s+([A-Za-z0-9_]+)\s*(?:extends\s+[^{]+)?\s*(?:implements\s+[^{]+)?\s*\{([\s\S]*?)\}/g;
  for (const m of text.matchAll(classRe)) {
    const name = m[1];
    const body = m[2];
    const fields = [];

    // private Type name;
    const fieldRe = /(private|protected|public)\s+([A-Za-z0-9_<>\[\]., ?]+)\s+([A-Za-z0-9_]+)\s*;/g;
    for (const fm of body.matchAll(fieldRe)) {
      const type = fm[2].replace(/\s+/g, ' ').trim();
      const fname = fm[3].trim();
      fields.push({ name: fname, type });
    }

    // Lombok @Data 등은 필드 선언만 있으면 위에서 잡힘
    if (fields.length) classIndex.set(name, { fields, file });
  }
};

const parseKotlinClasses = (text, file) => {
  // data class Foo(val name: String, val age: Int)
  const dataRe = /\bdata\s+class\s+([A-Za-z0-9_]+)\s*\(([\s\S]*?)\)/g;
  for (const m of text.matchAll(dataRe)) {
    const name = m[1];
    const params = m[2];
    const fields = [];
    // val foo: String, var bar: Int?
    const pRe = /(val|var)\s+([A-Za-z0-9_]+)\s*:\s*([A-Za-z0-9_<>,?.\[\]]+)/g;
    for (const pm of params.matchAll(pRe)) {
      fields.push({ name: pm[2], type: pm[3].trim() });
    }
    if (fields.length) classIndex.set(name, { fields, file });
  }

  // 일반 class { val foo: String = ... }
  const classRe = /\bclass\s+([A-Za-z0-9_]+)\s*(?:\((?:[\s\S]*?)\))?\s*\{([\s\S]*?)\}/g;
  for (const m of text.matchAll(classRe)) {
    const name = m[1];
    const body = m[2];
    const fields = [];
    const fRe = /\b(val|var)\s+([A-Za-z0-9_]+)\s*:\s*([A-Za-z0-9_<>,?.\[\]]+)/g;
    for (const fm of body.matchAll(fRe)) {
      fields.push({ name: fm[2], type: fm[3].trim() });
    }
    if (fields.length) classIndex.set(name, { fields, file });
  }
};

// 인덱싱 실행
for (const f of allFiles) {
  const ext = path.extname(f);
  const text = readText(f);
  if (ext === '.java') parseJavaClasses(text, f);
  if (ext === '.kt') parseKotlinClasses(text, f);
}

// -------- 타입 → 샘플 객체 생성 (재귀, 제네릭/배열 처리) --------
const GENERIC_RE = /([A-Za-z0-9_]+)\s*<\s*([A-Za-z0-9_<>,?\[\]. ]+)\s*>/;

const resolveTypeToSample = (rawType, depth = 0) => {
  if (depth > 3) return {}; // 너무 깊으면 중단

  let t = (rawType || '').trim();
  t = t.replace(/\?$/,''); // Kotlin nullable
  // 배열/리스트
  if (/\[\]$/.test(t)) {
    const base = t.replace(/\[\]$/,'').trim();
    return [resolveTypeToSample(base, depth + 1)];
  }
  if (/^(List|Array|MutableList|Set|Collection)\b/i.test(t)) {
    const gm = t.match(GENERIC_RE);
    const arg = gm ? gm[2].split(',')[0].trim() : 'string';
    return [resolveTypeToSample(arg, depth + 1)];
  }
  if (/^Map\b/i.test(t)) {
    return {};
  }

  // 제네릭 타입 Foo<Bar>
  const gm = t.match(GENERIC_RE);
  if (gm) {
    const outer = gm[1];
    const inner = gm[2].split(',')[0].trim();
    // List<Foo> 같은 건 위에서 처리됨. 나머지는 outer 자체를 DTO로 시도한 뒤 실패 시 inner로 시도
    const dto = classIndex.get(outer);
    if (dto) return objectFromClass(dto, depth + 1);
    return resolveTypeToSample(inner, depth + 1);
  }

  // 원시/표준
  const prim = typeSample(t);
  if (prim !== 'string' || /^string$/i.test(t)) return prim;

  // DTO/POJO
  const dto = classIndex.get(t);
  if (dto) return objectFromClass(dto, depth + 1);

  // 패키지 경로가 포함된 타입(java.lang.String 등) → 마지막 토큰 재시도
  if (t.includes('.')) {
    const last = t.split('.').pop();
    if (classIndex.has(last)) return objectFromClass(classIndex.get(last), depth + 1);
  }

  return 'string';
};

const objectFromClass = (dto, depth) => {
  const obj = {};
  for (const f of dto.fields) {
    obj[f.name] = resolveTypeToSample(f.type, depth + 1);
  }
  return obj;
};

// -------- Swagger 설명 추출 (그대로 유지) --------
const extractSwaggerSpring = (text, idx) => {
  const around = text.slice(Math.max(0, idx - 2000), idx + 2000);
  const out = { description: '', contentType: null };
  const op = around.match(/@Operation\s*\(\s*[^)]*description\s*=\s*"(.*?)"/s);
  if (op) out.description = (op[1] || '').trim();
  const apiOp = around.match(/@ApiOperation\s*\(\s*[^)]*notes\s*=\s*"(.*?)"/s);
  if (!out.description && apiOp) out.description = (apiOp[1] || '').trim();
  const cons = around.match(/consumes\s*=\s*"(.*?)"/);
  if (cons) out.contentType = cons[1].trim();
  const mt = around.match(/mediaType\s*=\s*"(.*?)"/);
  if (!out.contentType && mt) out.contentType = mt[1].trim();

  // swagger-jsdoc 스타일은 Spring에선 거의 없지만, 남겨둠 (무시 가능)
  return out;
};

// 백업 설명(주석) – Swagger가 없을 때만
const extractNearbyComment = (text, idx) => {
  const upToIdx = text.slice(0, idx);
  const blockIdx = upToIdx.lastIndexOf('/**');
  const endIdx = upToIdx.lastIndexOf('*/');
  if (blockIdx !== -1 && endIdx !== -1 && endIdx > blockIdx) {
    const block = upToIdx.slice(blockIdx, endIdx + 2);
    const lines = block.split('\n').map((l) => l.replace(/^\s*\/?\**\s?/, '').trim()).filter(Boolean);
    if (lines.length) return lines.join(' ');
  }
  const lines = upToIdx.split('\n');
  const picked = [];
  for (let i = lines.length - 1; i >= 0; i--) {
    const m = lines[i].match(/^\s*\/\/\s?(.*)$/);
    if (m) picked.unshift(m[1].trim());
    else break;
  }
  return picked.join(' ');
};

const contentTypeFromNearby = (text, idx) => {
  const around = text.slice(Math.max(0, idx - 1500), idx + 1500);
  if (/multipart\/form-data/i.test(around)) return 'multipart/form-data';
  if (/application\/x-www-form-urlencoded/i.test(around)) return 'application/x-www-form-urlencoded';
  return 'application/json';
};

// -------- 스캔 결과 --------
const endpoints = [];

// -------- Spring 엔드포인트 스캔 (RequestBody만 본다) --------
// CHANGED: RequestBody 샘플 생성 로직을 "오직 @RequestBody 타입"으로 제한
for (const file of allFiles) {
  const ext = path.extname(file);
  if (ext !== '.java' && ext !== '.kt') continue;

  const text = readText(file);
  if (!text) continue;
  const rel = path.relative(root, file);

  const hasCtrl = /@(RestController|Controller)\b/.test(text);
  if (!hasCtrl) continue;

  // 클래스-level @RequestMapping prefix
  let classPrefix = '';
  const cp =
    [...text.matchAll(/@RequestMapping\s*\(\s*(?:value\s*=\s*)?['"`]([^'"`]+)['"`]\s*\)/g)].pop() ||
    [...text.matchAll(/@RequestMapping\s*\(\s*['"`]([^'"`]+)['"`]\s*\)/g)].pop();
  if (cp) classPrefix = (cp[1] || '').trim();

  const mapRe = /@(GetMapping|PostMapping|PutMapping|DeleteMapping|PatchMapping)\s*\(\s*['"`]?([^'"`)]*)['"`]?\s*\)[\s\S]*?\{/g;
  for (const m of text.matchAll(mapRe)) {
    const idx = m.index || 0;
    const method = m[1].replace('Mapping', '').toUpperCase();
    const sub = (m[2] || '').trim();
    const full = normPath('/' + [classPrefix, sub].filter(Boolean).join('/'));
    const version = extractVersion(full);

    const swag = extractSwaggerSpring(text, idx);
    const description = swag.description || extractNearbyComment(text, idx);
    const contentType = swag.contentType || contentTypeFromNearby(text, idx);

    // 메서드 시그니처 근처에서 @RequestBody 타입 찾기 (Java/Kotlin)
    const after = text.slice(idx, idx + 1000);

    // Java: public Resp create(@RequestBody CreateReq req)
    // Kotlin: fun create(@RequestBody req: CreateReq)
    let rbType = null;

    const javaRB = after.match(/@RequestBody\s+([A-Za-z0-9_<>$begin:math:display$$end:math:display$.]+)\s+[A-Za-z0-9_]+/);
    if (javaRB) {
      rbType = (javaRB[1] || '').replace(/<.*?>/g, '').trim();
    } else {
      const ktRB = after.match(/@RequestBody\s+[A-Za-z0-9_]+\s*:\s*([A-Za-z0-9_<>$begin:math:display$$end:math:display$.]+)/);
      if (ktRB) rbType = (ktRB[1] || '').replace(/<.*?>/g, '').trim();
    }

    let requestBodySample = null;
    if (rbType) {
      requestBodySample = resolveTypeToSample(rbType, 0); // CHANGED: DTO/Zod/Joi/req.body 사용 없음
    }

    endpoints.push({
      framework: 'spring',
      method,
      path: full,
      version,
      file: rel,
      line: indexToLine(text, idx),
      handler: '',                 // (원하면 메서드명 추출도 추가 가능)
      description,
      contentType,
      requestBodySample
    });
  }
}

// -------- 중복 제거 & 저장 --------
const seen = new Set();
const out = [];
for (const e of endpoints) {
  const k = `${e.framework}|${e.method}|${e.path}|${e.file}|${e.line}`;
  if (seen.has(k)) continue;
  seen.add(k);
  out.push(e);
}

const outPath = path.join(root, '.api-scan.json');
fs.writeFileSync(outPath, JSON.stringify(out, null, 2));
console.log(`Found ${out.length} endpoints -> ${outPath}`);