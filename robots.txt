// tools/scan-apis.mjs
// 목표: Spring 프로젝트의 HTTP 엔드포인트를 스캔하고,
//  - version (경로 맨 앞 v1/v2 등)
//  - Swagger 설명(@Operation/@ApiOperation 우선)
//  - requestBodySample: 오직 @RequestBody 타입의 DTO/Model 파일 내용만으로 생성
//  - requestBodySchema: DTO 메타(필수/설명/enum/format/example)
// 을 .api-scan.json에 저장
//
// 환경: Node (ESM), Windows 11 가정, 외부 라이브러리 없음.

import fs from 'fs';
import path from 'path';

const root = process.cwd();
const SRC_DIRS = ['src', 'src/main/java', 'src/main/kotlin'];
const TARGET_EXTS = new Set(['.java', '.kt']); // 스프링 위주. 필요 시 추가
const MAX_DEPTH = 3;

// ---------- 유틸 ----------
const normPath = (p) => (p || '').replace(/\/+/g, '/').replace(/\/$/, '') || '/';
const extractVersion = (p) => {
  const m = /^\/?(v\d+)\b/i.exec(p || '');
  return m ? m[1].toLowerCase() : null;
};
const readText = (f) => { try { return fs.readFileSync(f, 'utf8'); } catch { return ''; } };
const indexToLine = (text, idx) => text.slice(0, idx).split('\n').length;

const walk = (dir, out = []) => {
  if (!fs.existsSync(dir)) return out;
  for (const ent of fs.readdirSync(dir, { withFileTypes: true })) {
    if (ent.name.startsWith('.')) continue;
    const p = path.join(dir, ent.name);
    if (ent.isDirectory()) walk(p, out);
    else {
      const ext = path.extname(ent.name);
      if (TARGET_EXTS.has(ext)) out.push(p);
    }
  }
  return out;
};

// ---------- 타입/예시 헬퍼 ----------
const primitiveSample = (t) => {
  const s = (t || '').toLowerCase();
  if (/(^|[\W_])(int|long|double|float|number|bigdecimal)([\W_]|$)/.test(s)) return 0;
  if (/bool|boolean/.test(s)) return true;
  if (/date|localdate|localdatetime|instant|zoneddatetime|offsetdatetime/.test(s)) return '2025-01-01T00:00:00Z';
  if (/uuid/.test(s)) return '00000000-0000-0000-0000-000000000000';
  if (/byte\[\]|bytes/.test(s)) return '';
  if (/string|char|text/i.test(s)) return 'string';
  return 'string';
};
const primitiveFormat = (t) => {
  const s = (t || '').toLowerCase();
  if (/uuid/.test(s)) return 'uuid';
  if (/date|time|instant|zoneddatetime|offsetdatetime/i.test(s)) return 'date-time';
  if (/email/.test(s)) return 'email';
  return undefined;
};

// ---------- 클래스/필드 파싱 인덱스 ----------
/**
 * classIndex: Map<className, {
 *   kind: 'class'|'enum',
 *   file: string,
 *   fields?: [{ name, type, nullable, annotations: string[], schemaDesc?, schemaExample?, jsonName? }],
 *   enumValues?: string[]
 * }>
 */
const classIndex = new Map();

const parseJava = (text, file) => {
  // enum
  for (const m of text.matchAll(/\benum\s+([A-Za-z0-9_]+)\s*\{([\s\S]*?)\}/g)) {
    const name = m[1];
    const body = m[2];
    // 값들: FOO, BAR(1), BAZ
    const values = (body.split('\n')[0] || '')
      .split(',')
      .map(v => v.trim())
      .filter(v => /^[A-Z0-9_]+(\s*\(.*\))?$/.test(v))
      .map(v => v.replace(/\(.*\)/, '').trim());
    classIndex.set(name, { kind: 'enum', file, enumValues: values });
  }

  // class
  for (const m of text.matchAll(/\bclass\s+([A-Za-z0-9_]+)\s*(?:extends\s+[^{]+)?\s*(?:implements\s+[^{]+)?\s*\{([\s\S]*?)\}/g)) {
    const name = m[1];
    const body = m[2];
    const fields = [];

    // 필드 블록 내에서 줄 단위로 주석/어노테이션/필드 포착
    const lines = body.split('\n');
    let annos = [];
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // 어노테이션 누적
      const a = line.match(/^@([A-Za-z0-9_.]+)(\((.*)\))?/);
      if (a) { annos.push(line); continue; }

      // private Type name;  (제네릭/배열 포함)
      const f = line.match(/(private|protected|public)\s+([A-Za-z0-9_<>\[\]., ?]+)\s+([A-Za-z0-9_]+)\s*;/);
      if (f) {
        const type = f[2].replace(/\s+/g, ' ').trim();
        const name = f[3].trim();

        // 파생 메타
        let schemaDesc, schemaExample, jsonName, nullable = true;

        // 필요한 어노테이션 해석
        for (const an of annos) {
          if (/NotNull|NotBlank/i.test(an)) nullable = false;
          const sdesc = an.match(/@Schema\s*\(\s*[^)]*description\s*=\s*"(.*?)"/s);
          if (sdesc) schemaDesc = sdesc[1].trim();
          const sex = an.match(/@Schema\s*\(\s*[^)]*example\s*=\s*"(.*?)"/s);
          if (sex) schemaExample = sex[1].trim();
          const jn = an.match(/@JsonProperty\s*\(\s*"(.*?)"\s*\)/);
          if (jn) jsonName = jn[1].trim();
          if (/Email/i.test(an)) schemaDesc = schemaDesc || 'email';
          const fmt = an.match(/@JsonFormat\s*\(\s*[^)]*pattern\s*=\s*"(.*?)"/);
          if (fmt) schemaDesc = schemaDesc || `format: ${fmt[1]}`;
        }

        fields.push({ name, type, nullable, annotations: [...annos], schemaDesc, schemaExample, jsonName });
        annos = [];
      }
    }

    if (fields.length || classIndex.has(name)) {
      classIndex.set(name, { kind: 'class', file, fields });
    }
  }
};

const parseKotlin = (text, file) => {
  // enum class Foo { A, B, C }
  for (const m of text.matchAll(/\benum\s+class\s+([A-Za-z0-9_]+)\s*\{([\s\S]*?)\}/g)) {
    const name = m[1];
    const body = m[2];
    const values = (body.split('\n')[0] || '')
      .split(',')
      .map(v => v.trim())
      .filter(v => /^[A-Z0-9_]+$/.test(v));
    classIndex.set(name, { kind: 'enum', file, enumValues: values });
  }

  // data class Foo(@field:NotNull val name: String, val age: Int?)
  for (const m of text.matchAll(/\bdata\s+class\s+([A-Za-z0-9_]+)\s*\(([\s\S]*?)\)/g)) {
    const name = m[1];
    const params = m[2];
    const fields = [];
    for (const pm of params.matchAll(/(@[A-Za-z0-9_:.() ,"=]*\s*)?(val|var)\s+([A-Za-z0-9_]+)\s*:\s*([A-Za-z0-9_<>,?.\[\]]+)(\s*=\s*[^,)]*)?/g)) {
      const rawAnno = (pm[1] || '').trim();
      const fname = pm[3];
      const ftype = pm[4].trim();
      const hasQ = /\?$/.test(ftype);
      let schemaDesc, schemaExample, jsonName;
      let nullable = hasQ;

      if (/NotNull|NotBlank/i.test(rawAnno)) nullable = false;
      const sdesc = rawAnno.match(/@Schema\s*\(\s*[^)]*description\s*=\s*"(.*?)"/s);
      if (sdesc) schemaDesc = sdesc[1].trim();
      const sex = rawAnno.match(/@Schema\s*\(\s*[^)]*example\s*=\s*"(.*?)"/s);
      if (sex) schemaExample = sex[1].trim();
      const jn = rawAnno.match(/@JsonProperty\s*\(\s*"(.*?)"\s*\)/);
      if (jn) jsonName = jn[1].trim();

      fields.push({ name: fname, type: ftype, nullable, annotations: rawAnno ? [rawAnno] : [], schemaDesc, schemaExample, jsonName });
    }
    classIndex.set(name, { kind: 'class', file, fields });
  }

  // 일반 class { val foo: String ... }
  for (const m of text.matchAll(/\bclass\s+([A-Za-z0-9_]+)\s*(?:\((?:[\s\S]*?)\))?\s*\{([\s\S]*?)\}/g)) {
    const name = m[1];
    const body = m[2];
    const fields = [];
    let lastAnno = [];
    for (const fm of body.matchAll(/^\s*(@[A-Za-z0-9_:.() ,"=]+)\s*$|^\s*(val|var)\s+([A-Za-z0-9_]+)\s*:\s*([A-Za-z0-9_<>,?.\[\]]+)/gm)) {
      if (fm[1]) {
        lastAnno.push(fm[1]);
        continue;
      }
      const fname = fm[3];
      const ftype = fm[4].trim();
      const hasQ = /\?$/.test(ftype);
      let schemaDesc, schemaExample, jsonName;
      let nullable = hasQ;
      const rawAnno = lastAnno.join(' '); lastAnno = [];

      if (/NotNull|NotBlank/i.test(rawAnno)) nullable = false;
      const sdesc = rawAnno.match(/@Schema\s*\(\s*[^)]*description\s*=\s*"(.*?)"/s);
      if (sdesc) schemaDesc = sdesc[1].trim();
      const sex = rawAnno.match(/@Schema\s*\(\s*[^)]*example\s*=\s*"(.*?)"/s);
      if (sex) schemaExample = sex[1].trim();
      const jn = rawAnno.match(/@JsonProperty\s*\(\s*"(.*?)"\s*\)/);
      if (jn) jsonName = jn[1].trim();

      fields.push({ name: fname, type: ftype, nullable, annotations: rawAnno ? [rawAnno] : [], schemaDesc, schemaExample, jsonName });
    }
    if (fields.length) classIndex.set(name, { kind: 'class', file, fields });
  }
};

// ---------- 타입 해석 & 스키마/샘플 생성 ----------
const GENERIC_RE = /([A-Za-z0-9_$.]+)\s*<\s*([A-Za-z0-9_<>,?.\[\] $.]+)\s*>/;

const resolveToSchemaAndSample = (rawType, depth = 0) => {
  if (!rawType) return [{ type: 'string' }, 'string'];
  if (depth > MAX_DEPTH) return [{ type: 'object' }, {}];

  let t = rawType.trim().replace(/\s+/g, ' ');
  // 배열/리스트
  if (/\[\]$/.test(t)) {
    const base = t.replace(/\[\]$/, '').trim();
    const [itemSchema, itemSample] = resolveToSchemaAndSample(base, depth + 1);
    return [{ type: 'array', items: itemSchema }, [itemSample]];
  }
  if (/^(List|Array|MutableList|Set|Collection)\b/i.test(t)) {
    const gm = t.match(GENERIC_RE);
    const arg = gm ? gm[2].split(',')[0].trim() : 'string';
    const [itemSchema, itemSample] = resolveToSchemaAndSample(arg, depth + 1);
    return [{ type: 'array', items: itemSchema }, [itemSample]];
  }
  if (/^Map\b/i.test(t)) {
    return [{ type: 'object', additionalProperties: true }, {}];
  }

  // 제네릭 Foo<Bar>
  const gm = t.match(GENERIC_RE);
  if (gm) {
    const outer = stripPkg(gm[1]);
    const inner = gm[2].split(',')[0].trim();
    const dto = classIndex.get(outer);
    if (dto) {
      return fromClass(dto, depth + 1);
    }
    return resolveToSchemaAndSample(inner, depth + 1);
  }

  // 패키지 경로 제거(java.lang.String → String)
  t = stripPkg(t);

  // enum
  const enumHit = classIndex.get(t);
  if (enumHit && enumHit.kind === 'enum') {
    const schema = { type: 'string', enum: enumHit.enumValues || [] };
    const sample = (enumHit.enumValues && enumHit.enumValues[0]) || 'ENUM';
    return [schema, sample];
  }

  // DTO/POJO
  const dto = classIndex.get(t);
  if (dto && dto.kind === 'class') {
    return fromClass(dto, depth + 1);
  }

  // 원시
  const base = primitiveSample(t);
  const fmt = primitiveFormat(t);
  const schema = { type: typeof base === 'number' ? 'number' : (typeof base === 'boolean' ? 'boolean' : 'string') };
  if (fmt) schema.format = fmt;
  return [schema, base];
};

const stripPkg = (t) => t.includes('.') ? t.split('.').pop() : t;

const fromClass = (dto, depth) => {
  const properties = {};
  const required = [];
  for (const f of (dto.fields || [])) {
    const name = f.jsonName || f.name;
    const [sch, sample] = resolveToSchemaAndSample(f.type, depth + 1);

    // 필드 메타 merge
    if (f.schemaDesc) sch.description = (sch.description ? (sch.description + ' ') : '') + f.schemaDesc;
    const fmt = primitiveFormat(f.type);
    if (fmt && !sch.format) sch.format = fmt;

    if (f.schemaExample) {
      const ex = coerceExample(f.schemaExample, sch);
      if (ex !== undefined) sch.example = ex;
    }

    properties[name] = sch;
    if (!f.nullable) required.push(name);
  }

  const schema = { type: 'object', properties };
  if (required.length) schema.required = required;

  // 샘플 생성: example 우선, 없으면 기본값
  const sample = {};
  for (const [k, sch] of Object.entries(properties)) {
    if (sch.example !== undefined) sample[k] = sch.example;
    else sample[k] = sampleFromSchema(sch);
  }
  return [schema, sample];
};

const coerceExample = (raw, schema) => {
  if (raw === undefined) return undefined;
  try {
    if (schema.type === 'number') return Number(raw);
    if (schema.type === 'boolean') return /^(true|1)$/i.test(raw);
    if (schema.type === 'array') {
      // 콤마 분할 or JSON
      if (raw.trim().startsWith('[')) return JSON.parse(raw);
      return [raw];
    }
    if (schema.type === 'object') {
      if (raw.trim().startsWith('{')) return JSON.parse(raw);
      return undefined;
    }
    return raw;
  } catch { return undefined; }
};

const sampleFromSchema = (sch) => {
  if (sch.example !== undefined) return sch.example;
  if (sch.type === 'number') return 0;
  if (sch.type === 'boolean') return true;
  if (sch.type === 'string') {
    if (sch.format === 'uuid') return '00000000-0000-0000-0000-000000000000';
    if (sch.format === 'date-time') return '2025-01-01T00:00:00Z';
    return 'string';
  }
  if (sch.type === 'array') return [sampleFromSchema(sch.items || { type: 'string' })];
  if (sch.type === 'object') {
    const obj = {};
    for (const [k, v] of Object.entries(sch.properties || {})) obj[k] = sampleFromSchema(v);
    return obj;
  }
  return 'string';
};

// ---------- Swagger 설명(스프링) ----------
const extractSwaggerSpring = (text, idx) => {
  const around = text.slice(Math.max(0, idx - 2000), idx + 2000);
  const out = { description: '', contentType: null };
  const op = around.match(/@Operation\s*\(\s*[^)]*description\s*=\s*"(.*?)"/s);
  if (op) out.description = (op[1] || '').trim();
  const apiOp = around.match(/@ApiOperation\s*\(\s*[^)]*notes\s*=\s*"(.*?)"/s);
  if (!out.description && apiOp) out.description = (apiOp[1] || '').trim();
  const cons = around.match(/consumes\s*=\s*"(.*?)"/);
  if (cons) out.contentType = cons[1].trim();
  const mt = around.match(/mediaType\s*=\s*"(.*?)"/);
  if (!out.contentType && mt) out.contentType = mt[1].trim();
  return out;
};

// ---------- 1) 파일 스캔 & DTO 인덱싱 ----------
const files = SRC_DIRS.flatMap((d) => walk(path.join(root, d)));
for (const f of files) {
  const ext = path.extname(f);
  const txt = readText(f);
  if (!txt) continue;
  if (ext === '.java') parseJava(txt, f);
  if (ext === '.kt') parseKotlin(txt, f);
}

// ---------- 2) 엔드포인트 스캔 (Spring) ----------
const endpoints = [];
for (const file of files) {
  const ext = path.extname(file);
  if (ext !== '.java' && ext !== '.kt') continue;

  const text = readText(file);
  if (!text) continue;
  const rel = path.relative(root, file);
  const hasCtrl = /@(RestController|Controller)\b/.test(text);
  if (!hasCtrl) continue;

  // 클래스 레벨 prefix
  let classPrefix = '';
  const cp =
    [...text.matchAll(/@RequestMapping\s*\(\s*(?:value\s*=\s*)?['"`]([^'"`]+)['"`]\s*\)/g)].pop() ||
    [...text.matchAll(/@RequestMapping\s*\(\s*['"`]([^'"`]+)['"`]\s*\)/g)].pop();
  if (cp) classPrefix = (cp[1] || '').trim();

  const mapRe = /@(GetMapping|PostMapping|PutMapping|DeleteMapping|PatchMapping)\s*\(\s*['"`]?([^'"`)]*)['"`]?\s*\)[\s\S]*?\{/g;
  for (const m of text.matchAll(mapRe)) {
    const idx = m.index || 0;
    const method = m[1].replace('Mapping', '').toUpperCase();
    const sub = (m[2] || '').trim();
    const full = normPath('/' + [classPrefix, sub].filter(Boolean).join('/'));
    const version = extractVersion(full);

    const swag = extractSwaggerSpring(text, idx);
    const description = swag.description;
    const contentType = swag.contentType || 'application/json';

    // @RequestBody 타입 추출 (Java/Kotlin)
    const after = text.slice(idx, idx + 1200);
    let rbType = null;

    // Java: @RequestBody CreateReq req
    const javaRB = after.match(/@RequestBody\s+([A-Za-z0-9_<>$begin:math:display$$end:math:display$.$]+)\s+[A-Za-z0-9_]+/);
    if (javaRB) rbType = javaRB[1].replace(/<.*?>/g, '').trim();
    // Kotlin: @RequestBody req: CreateReq
    if (!rbType) {
      const ktRB = after.match(/@RequestBody\s+[A-Za-z0-9_]+\s*:\s*([A-Za-z0-9_<>$begin:math:display$$end:math:display$.$]+)/);
      if (ktRB) rbType = ktRB[1].replace(/<.*?>/g, '').trim();
    }

    let requestBodySchema = null;
    let requestBodySample = null;

    if (rbType) {
      const [sch, sample] = resolveToSchemaAndSample(rbType, 0);
      requestBodySchema = sch;
      requestBodySample = sample;
    }

    endpoints.push({
      framework: 'spring',
      method,
      path: full,
      version,
      file: rel,
      line: indexToLine(text, idx),
      handler: '', // 필요 시 함수명 파싱 추가 가능
      description,
      contentType,
      requestBodySchema,
      requestBodySample
    });
  }
}

// ---------- 3) 중복 제거 & 저장 ----------
const seen = new Set();
const out = [];
for (const e of endpoints) {
  const k = `${e.framework}|${e.method}|${e.path}|${e.file}|${e.line}`;
  if (seen.has(k)) continue;
  seen.add(k);
  out.push(e);
}

const outPath = path.join(root, '.api-scan.json');
fs.writeFileSync(outPath, JSON.stringify(out, null, 2));
console.log(`Found ${out.length} endpoints -> ${outPath}`);